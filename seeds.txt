create function public.handle_new_user () returns trigger as $$
begin
  insert into public.users (id, full_name, avatar_url, email, role, username)
  values (
    new.id,
     new.raw_user_meta_data->>'full_name', 
     new.raw_user_meta_data->>'avatar_url',
     new.email,
     new.raw_user_meta_data->>'role',
     new.raw_user_meta_data->>'username');
  return new;
end;
$$ language plpgsql security definer;

create trigger on_auth_user_created
after insert on auth.users 
for each row execute procedure public.handle_new_user ();


create table
  public.agencies (
    id uuid not null default gen_random_uuid (),
    created_at timestamp with time zone not null default now(),
    agency_name text not null default ''::text,
    agency_email text null,
    agency_logo_url text null default ''::text,
    agency_address jsonb null,
    agency_website text null,
    agency_status text not null default ''::text,
    constraint companies_pkey primary key (id)
  ) tablespace pg_default;

  create table
  public.users (
    id uuid not null,
    updated_at timestamp with time zone null default now(),
    username text null default ''::text,
    full_name text null default ''::text,
    avatar_url text null default ''::text,
    agency_id uuid null,
    role public.role null,
    email text not null default ''::text,
    status text not null default ''::text,
    constraint profiles_pkey primary key (id),
    constraint profiles_username_key unique (username),
    constraint users_agency_id_fkey foreign key (agency_id) references agencies (id) on update cascade on delete cascade,
    constraint users_id_fkey foreign key (id) references auth.users (id) on update cascade on delete cascade,
    constraint username_length check ((char_length(username) >= 3))
  ) tablespace pg_default;

create index if not exists users_agency_id_idx on public.users using btree (agency_id) tablespace pg_default;